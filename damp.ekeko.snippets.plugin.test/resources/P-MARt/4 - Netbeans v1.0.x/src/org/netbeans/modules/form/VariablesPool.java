/*
 *                 Sun Public License Notice
 * 
 * The contents of this file are subject to the Sun Public License
 * Version 1.0 (the "License"). You may not use this file except in
 * compliance with the License. A copy of the License is available at
 * http://www.sun.com/
 * 
 * The Original Code is Forte for Java, Community Edition. The Initial
 * Developer of the Original Code is Sun Microsystems, Inc. Portions
 * Copyright 1997-2000 Sun Microsystems, Inc. All Rights Reserved.
 */

package org.netbeans.modules.form;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

/** A VariablesPool manages a pool of global variables for one form.
* It manages both the namespace of all global variables (so that a name of 
* some hand-created variable is not used for generated variables) together 
* with the list of variables that are generated by form editor.
*
* @author   Ian Formanek
*/
final public class VariablesPool  {
    // -----------------------------------------------------------------------------
    // Private variables

    /** The list of all assigned variable names within the form 
     * @associates Variable*/
    private ArrayList variables = new ArrayList();

    /** The space of used variable names - HashMap <String, String> */
    private HashMap nameSpace = new HashMap (20);
    /** The space of used variable names which survive reparsing - HashMap <String, String> 
     * @associates String*/
    private HashMap nameSpaceFixed = new HashMap (10);
    /** The last used index for default names - HashMap <Class, Integer> 
     * @associates Integer*/
    private HashMap usedIndexes = new HashMap (10);

    /** The FormManager2 for this form */
    private FormManager2 manager;

    // FINALIZE DEBUG METHOD
    public void finalize () throws Throwable {
        super.finalize ();
        if (System.getProperty ("netbeans.debug.form.finalize") != null) {
            System.out.println("finalized: "+this.getClass ().getName ()+", instance: "+this); // NOI18N
        }
    } // FINALIZE DEBUG METHOD

    // -----------------------------------------------------------------------------
    // Constructors

    /** Constructs a new VariablesPool for specified FormManager2.
    * @param manager The FormManager2
    */
    public VariablesPool (FormManager2 manager) {
        this.manager = manager;
    }

    // -----------------------------------------------------------------------------
    // Public interface

    /** This method should be called after (succesfull) reparsing of the
    * source to update the namespace of global variables.
    * @param names The list of names for all global variables
    */
    public void updateNameSpace (String[] names) {
        nameSpace.clear ();
        for (Iterator it = nameSpaceFixed.keySet ().iterator (); it.hasNext (); ) {
            Object name = it.next ();
            nameSpace.put (name, name);
        }

        for (int i = 0; i < names.length; i++)
            nameSpace.put (names[i], names [i]);
    }

    /** Returns a new free variable name for specified Class.
    * @param clazz The class to return the name for
    */
    public String getNewName(Class clazz) {
        int index = 1;
        Integer lastIndex = (Integer)usedIndexes.get (clazz);
        if (lastIndex == null) {
            usedIndexes.put (clazz, new Integer (1));
        } else {
            index = lastIndex.intValue () + 1;
            usedIndexes.put (clazz, new Integer (index));
        }
        String prefix = org.openide.util.Utilities.getShortClassName (clazz);
        prefix = Character.toLowerCase (prefix.charAt (0)) + prefix.substring (1); // remove capitalization on the beginning

        while (true) {
            String name = prefix + index;
            if (nameSpace.get (name) == null) {
                nameSpace.put (name, name);
                return name;
            }
            index++;
        }
    }

    public void reserveName (String varName) {
        nameSpace.put (varName, varName);
    }

    /** Reserves specified identifier to survive reparsing.
    * Can be useful for situations, where the name should be reserved even if it is not provided by the parser
    * (e.g. a local variable in a method).
    */
    public void reserveNameSurviveReparse (String varName) {
        nameSpaceFixed.put (varName, varName);
    }

    /** Releases specified identifier (which was reserved using reserveNameSurviveReparse () to survive reparsing).
    */
    public void releaseNameSurviveReparse (String varName) {
        nameSpaceFixed.remove (varName);
    }

    /** Checks whether a variable of specified name is already declared.
    * @param varName a string variable name
    * @return true if the specified variable name is already declared, false otherwise 
    */
    public boolean isReserved (String varName) {
        return (nameSpace.get (varName) != null);
    }

    /** Creates a new variable with specified name and type.
    * @param name The name of the variable
    * @param type The type of the variable
    */
    void createVariable (String name, Class type) {
        Variable var = new Variable (name, type);
        variables.add (var);
        nameSpace.put (var.getVariableName (), var.getVariableName ());
    }

    /** Finds the variable of specified name and releases it from the variables pool
    * @param name The name of the variable
    */
    void deleteVariable (String name) {
        Variable var = findVariable (name);
        if (var != null) {
            variables.remove (var);
            nameSpace.remove(name);
        }
    }


    /** Finds a class of variable with specified name.
    * @param name The name of the variable
    * @return The type of the variable if it exists, null otherwise
    */
    String findVariableType (String name) {
        for (Iterator it = variables.iterator (); it.hasNext (); ) {
            Variable v = (Variable)it.next ();
            if (name.equals (v.getVariableName ()))
                return v.getClassName ();
        }
        return null;
    }


    boolean renameVariable (String oldName, String newName) {
        Variable var = findVariable (oldName);
        if (var == null)
            return false;
        var.setVariableName (newName);
        nameSpace.remove (oldName);
        nameSpace.put (newName, newName);
        return true;
    }

    /** Finds a class of variable with specified name.
    * @param name The name of the variable
    * @return The type of the variable if it exists, null otherwise
    */
    private Variable findVariable (String name) {
        for (Iterator it = variables.iterator (); it.hasNext (); ) {
            Variable v = (Variable)it.next ();
            if (name.equals (v.getVariableName ()))
                return v;
        }
        return null;
    }

    // -----------------------------------------------------------------------------
    // Innerclasses

    final private static class Variable extends Object {
        Variable (String varName, String clName) {
            variableName = varName;
            className = clName;
        }

        Variable (String varName, Class clazz) {
            this (varName, clazz.getName ());
        }

        public String getVariableName () {
            return variableName;
        }

        void setVariableName (String name) {
            variableName = name;
        }

        public String getClassName () {
            return className;
        }

        void setClassName (String name) {
            className = name;
        }

        String variableName;
        String className;
    }

}

/*
 * Log
 *  8    Gandalf   1.7         1/17/00  Pavel Buzek     
 *  7    Gandalf   1.6         1/5/00   Ian Formanek    NOI18N
 *  6    Gandalf   1.5         10/23/99 Ian Formanek    NO SEMANTIC CHANGE - Sun
 *       Microsystems Copyright in File Comment
 *  5    Gandalf   1.4         10/9/99  Ian Formanek    Fixed bug 3896 - After 
 *       deleting a component from form, new component can't have the name of 
 *       the deleted one.
 *  4    Gandalf   1.3         7/25/99  Ian Formanek    cleaned up
 *  3    Gandalf   1.2         5/15/99  Ian Formanek    
 *  2    Gandalf   1.1         5/12/99  Ian Formanek    
 *  1    Gandalf   1.0         5/10/99  Ian Formanek    
 * $
 */
