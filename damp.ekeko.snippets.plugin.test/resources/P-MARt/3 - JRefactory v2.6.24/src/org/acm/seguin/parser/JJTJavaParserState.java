/*
 *  Author:  Chris Seguin
 *
 *  This software has been developed under the copyleft
 *  rules of the GNU General Public License.  Please
 *  consult the GNU General Public License for more
 *  details about use and distribution of this software.
 */
package org.acm.seguin.parser;
/*
 * Generated By:JJTree: Do not edit this line. JJTJavaParserState.java
 */

/**
 *  Description of the Class 
 *
 *@author     Chris Seguin 
 *@created    October 14, 1999 
 */
class JJTJavaParserState {
	private java.util.Stack nodes;
	private java.util.Stack marks;

	private int sp;
	// number of nodes on stack
	private int mk;
	// current mark
	private boolean node_created;


	/**
	 *  Constructor for the JJTJavaParserState object 
	 */
	JJTJavaParserState() {
		nodes = new java.util.Stack();
		marks = new java.util.Stack();
		sp = 0;
		mk = 0;
	}


	/*
	 * Determines whether the current node was actually closed and
	 * pushed.  This should only be called in the final user action of a
	 * node scope.
	 */
	/**
	 *  Description of the Method 
	 *
	 *@return    Description of the Returned Value 
	 */
	boolean nodeCreated() {
		return node_created;
	}


	/*
	 * Call this to reinitialize the node stack.  It is called
	 * automatically by the parser's ReInit() method.
	 */
	/**
	 *  Description of the Method 
	 */
	void reset() {
		nodes.removeAllElements();
		marks.removeAllElements();
		sp = 0;
		mk = 0;
	}


	/*
	 * Returns the root node of the AST.  It only makes sense to call
	 * this after a successful parse.
	 */
	/**
	 *  Description of the Method 
	 *
	 *@return    Description of the Returned Value 
	 */
	Node rootNode() {
		return (Node) nodes.elementAt(0);
	}


	/*
	 * Pushes a node on to the stack.
	 */
	/**
	 *  Description of the Method 
	 *
	 *@param  n  Description of Parameter 
	 */
	void pushNode(Node n) {
		nodes.push(n);
		++sp;
	}


	/*
	 * Returns the node on the top of the stack, and remove it from the
	 * stack.
	 */
	/**
	 *  Description of the Method 
	 *
	 *@return    Description of the Returned Value 
	 */
	Node popNode() {
		if (--sp < mk) {
			mk = ((Integer) marks.pop()).intValue();
		}
		return (Node) nodes.pop();
	}


	/*
	 * Returns the node currently on the top of the stack.
	 */
	/**
	 *  Description of the Method 
	 *
	 *@return    Description of the Returned Value 
	 */
	Node peekNode() {
		return (Node) nodes.peek();
	}


	/*
	 * Returns the number of children on the stack in the current node
	 * scope.
	 */
	/**
	 *  Description of the Method 
	 *
	 *@return    Description of the Returned Value 
	 */
	int nodeArity() {
		return sp - mk;
	}


	/**
	 *  Description of the Method 
	 *
	 *@param  n  Description of Parameter 
	 */
	void clearNodeScope(Node n) {
		while (sp > mk) {
			popNode();
		}
		mk = ((Integer) marks.pop()).intValue();
	}


	/**
	 *  Description of the Method 
	 *
	 *@param  n  Description of Parameter 
	 */
	void openNodeScope(Node n) {
		marks.push(new Integer(mk));
		mk = sp;
		n.jjtOpen();
	}


	/*
	 * A definite node is constructed from a specified number of
	 * children.  That number of nodes are popped from the stack and
	 * made the children of the definite node.  Then the definite node
	 * is pushed on to the stack.
	 */
	/**
	 *  Description of the Method 
	 *
	 *@param  n    Description of Parameter 
	 *@param  num  Description of Parameter 
	 */
	void closeNodeScope(Node n, int num) {
		mk = ((Integer) marks.pop()).intValue();
		while (num-- > 0) {
			Node c = popNode();
			c.jjtSetParent(n);
			n.jjtAddChild(c, num);
		}
		n.jjtClose();
		pushNode(n);
		node_created = true;
	}


	/*
	 * A conditional node is constructed if its condition is true.  All
	 * the nodes that have been pushed since the node was opened are
	 * made children of the the conditional node, which is then pushed
	 * on to the stack.  If the condition is false the node is not
	 * constructed and they are left on the stack.
	 */
	/**
	 *  Description of the Method 
	 *
	 *@param  n          Description of Parameter 
	 *@param  condition  Description of Parameter 
	 */
	void closeNodeScope(Node n, boolean condition) {
		if (condition) {
			int a = nodeArity();
			mk = ((Integer) marks.pop()).intValue();
			while (a-- > 0) {
				Node c = popNode();
				c.jjtSetParent(n);
				n.jjtAddChild(c, a);
			}
			n.jjtClose();
			pushNode(n);
			node_created = true;
		}
		else {
			mk = ((Integer) marks.pop()).intValue();
			node_created = false;
		}
	}
}
